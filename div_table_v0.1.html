<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>滚动分页表</title>
    <style>
      .table-container {
        position: relative;
        width: 500px;
        height: 500px;
        overflow: auto;
        border: 1px solid #ddd;
        contain: layout style; /* 提升滚动性能 */
      }

      .table-wrapper {
        position: relative;
        min-width: var(--table-min-width, 0);
        display: block;
      }

      .table-row {
        display: flex;
        /* 禁止自动换行, 固定行高才方便滚动 */
        white-space: nowrap;
      }

      .table-cell {
        box-sizing: border-box;
        overflow: hidden;
        text-overflow: ellipsis;
        border-right: 1px solid #eee;
        border-bottom: 1px solid #eee;
        display: flex;
        align-items: center;
        padding: 0 10px;
        font-size: 13px;
      }

      .row-header {
        position: sticky;
        top: 0;
        z-index: 40;
        background-color: #f8f9fa;
        font-weight: bold;
      }

      .row-summary {
        position: sticky;
        top: var(--header-height, 40);
        z-index: 38;
        background-color: #e6f7ff;
        font-weight: bold;
      }

      .cell-frozen {
        position: sticky;
        /* left 要动态计算 */
        z-index: 10;
        background-color: #fff;
      }

      .page-indicator {
        margin-top: 8px;
        font-size: 12px;
        color: #666;
      }
    </style>
  </head>
  <body>
    <h2>销售报表</h2>
    <div id="container"></div>

    <script>
      // 模拟数据生成, 分页的连续性
      // 第3页(pageIndex=2, size=100); limit 100 offset 200
      function genMockPage(pageIndex, size) {
        const depts = ['市场部', '销售部', '生产部']
        const regions = ['华南', '华东', '华北']
        const products = ['Ai智能眼镜', '学习平板']

        // 注意分页逻辑: 每页 100来算
        // 第1页: pageIndex=0, 1,2...100; offset=0x100
        // 第2页: pageIndex=1, 101,..200; ofset=1x100
        const start = pageIndex * size
        const list = []

        for (let i = 0; i < size; i++) {
          const idx = start + i
          list.push({
            name: `员工${idx + 1}`,
            dept: depts[idx % 3],
            region: regions[idx % 3],
            product: products[idx % 2],
            sales: `¥${(5 + Math.random() * 20).toFixed(1)}万`,
            cost: `¥${(2 + Math.random() * 10).toFixed(1)}万`,
            profit: `¥${(1 + Math.random() * 10).toFixed(1)}万`,
          })
        }
        return { data: list, total: 1_000_000 }
      }

      // test: 第一页
      // console.log('第2页:', genMockPage(1, 100))

      // 表格配置: 集中管理, 便于拓展
      const config = {
        container: '#container',
        frozenColumns: 2,
        hasHeader: true,
        showSummary: true,
        pageSize: 100,
        bufferPages: 1,
        maxRenderedPages: 10,

        rowHeight: {
          header: 30,
          summary: 38,
          data: 24,
        },

        // 列配置
        columns: [
          { key: 'name', title: '姓名', width: 100, sortable: true },
          {
            key: 'dept',
            title: '部门',
            width: 80,
            sortable: true,
            align: 'center',
          },
          { key: 'region', title: '区域', width: 80 },
          { key: 'product', title: '产品', width: 120 },
          {
            key: 'sales',
            title: '销售额',
            width: 100,
            align: 'right',
            render: (value) => `<span style="color:red">${value}</span>`,
          },
          {
            key: 'cost',
            title: '成本',
            width: 100,
            render: (value) => `<span style="color:orange">${value}</span>`,
          },
          {
            key: 'profit',
            title: '利润',
            width: 100,
            render: (value) => `<strong>${value}</strong>`,
          },
        ],

        // 数据加载接口: 后期替换为真实 api
        // { data, total }, 根据页码更新 data
        async fetchPage(pageIndex) {
          await new Promise((r) => setTimeout(r, 100))
          return genMockPage(pageIndex, config.pageSize)
        },

        async fetchSummary() {
          await new Promise((r) => setTimeout(r, 50))
          return {
            name: '合计',
            sales: '¥85亿',
            cost: '¥52亿',
            profit: '¥33亿',
          }
        },
      }

      // 全局状态管理
      let state = {
        columnLayout: [], // 处理后的列布局
        totalWidth: 0, // 表格总宽度
        totalRows: null, // 总行数
        pageCache: new Map(), // 缓存: pageIndex -> rowData[...]
        scrollContainer: null,
        wrapper: null, // 内容容器
        summaryRowData: null, // 汇总行原始数据
        pageIndicator: null, // 页码指示器 dom
      }

      // 主逻辑入口
      function init() {
        parseColumnLayout()
        createDOM()
        bindEvents()
        loadInitialData()
      }

      // 解析列配置: 加上 left, isFrozen
      function parseColumnLayout() {
        let left = 0
        state.columnLayout = config.columns.map((col, index) => {
          const isFrozen = index < config.frozenColumns
          const layout = {
            ...col,
            isFrozen,
            width: col.width || 100,
            leftOffset: isFrozen ? left : null,
          }
          if (isFrozen) {
            left += layout.width // 冻结列的关键!
          }
          return layout
        })

        state.totalWidth = state.columnLayout.reduce(
          (sum, col) => sum + col.width,
          0
        )
      }

      function createDOM() {
        // root -> container -> warpper -> row -> cell
        const rootEl = document.querySelector(config.container)
        rootEl.innerHTML = ''

        // 重点: 设置行高和表格宽, 是冻结行列的关键
        rootEl.style.setProperty('--table-min-width', `${state.totalWidth}px`)

        rootEl.style.setProperty(
          '--header-height',
          `${config.rowHeight.header}px`
        )

        // 将表格设置为滚动容器, 后续监听
        const scroller = document.createElement('div')
        scroller.className = 'table-container'

        const wrapper = document.createElement('div')
        wrapper.className = 'table-wrapper'

        const indicator = document.createElement('div')
        indicator.className = 'page-indicator'
        indicator.textContent = '加载中...'

        // 挂载: wrapper 要挂载到 scroller 之下
        rootEl.appendChild(scroller)
        rootEl.appendChild(indicator)
        scroller.appendChild(wrapper)

        // 保存引用到全局状态中去
        state.scrollContainer = scroller
        state.wrapper = wrapper
        state.pageIndicator = indicator
      }

      // 渲染单行 + 行内每个单元格(行数据, 列配置, 类型)
      // createRow(rowData, type); 后续可以拆分 createCell()
      // for 多行数据 -> 单行 -> for 多个单元格
      // type: header, summary, data
      // rowData: { name: '张三', dept: '销售部'....}
      function createRow(rowData, type) {
        const row = document.createElement('div')
        row.className = `table-row row-${type}`
        row.style.height = `${config.rowHeight[type]}px`

        state.columnLayout.forEach((col) => {
          const cell = document.createElement('div')
          cell.className = 'table-cell'
          cell.style.width = `${col.width}px`

          // 冻结列
          if (col.isFrozen) {
            cell.classList.add('cell-frozen')
            cell.style.left = `${col.leftOffset}px`
          }

          // 对齐
          if (col.align) {
            cell.style.justifyContent =
              col.aligin === 'right'
                ? 'flex-end'
                : col.aligin === 'center'
                ? center
                : 'flex-start'
          }

          // 内容渲染: 区分是表头, 总结行, 普通数据
          let content = ''
          if (type == 'header') {
            content = col.title
          } else if (type === 'summary') {
            content = state.summaryRowData?.[col.key] ?? ''
            console.log(content)
          } else {
            const value = rowData?.[col.key] ?? ''
            // 支持自定义渲染函数
            if (typeof col.render === 'function') {
              content = col.render(value, rowData, col)
            } else {
              content = value
            }
          }
          // 有 xss 风险用 innerHTML
          cell.innerHTML = content
          row.appendChild(cell)
        })

        return row
      }

      // 异步加载并缓存页面数据, 传入页码
      // pageCache<Map>: {0:[rowData...], 1:[rowData...]...}
      async function loadAndCachePage(pageIndex) {
        const res = await config.fetchPage(pageIndex)
        // 只存页面数据, 不立刻渲染, 后续由事件统一处理
        state.pageCache.set(pageIndex, res.data)
      }

      // 渲染当前缓存中的所有页面 (1, 2, 3, ...20封顶)
      function renderVisiblePages() {
        // 始终保留表头 + 总结行(若有)
        const staticRowCount =
          (config.hasHeader ? 1 : 0) + (config.showSummary ? 1 : 0)

        // 先清掉旧的数据行, 再重新渲染所有已缓存的页 (非只是可视区)
        while (state.wrapper.children.length > staticRowCount) {
          state.wrapper.removeChild(state.wrapper.lastChild)
        }

        // 重新渲染所有已缓存的页, 除了前2行表头+总结行外
        // 从第 0 页开始, 若在缓存<Map>中则取出来
        for (p = 0; p < config.maxRenderedPages; p++) {
          if (state.pageCache.get(p)) {
            const pageData = state.pageCache.get(p)
            // 创建一个 DocumentFragment, 高性能批插技巧
            // 遍历每页中的每行数据渲染为一行 dom, 塞进 fg, 最后批插
            const fragment = document.createDocumentFragment()
            pageData.forEach((rowData) => {
              fragment.appendChild(createRow(rowData, 'data'))
            })
            // 使用
            state.wrapper.appendChild(fragment)
          }
        }
      }

      // 响应式辅助: 更新汇总行 和 页面显示器
      function updateSummaryDisplay() {
        // 没配置, 或者配置了没数据, 则不处理
        if (!config.showSummary || !state.summaryRowData) return

        const summaryRowIndex = config.hasHeader ? 1 : 0
        const oldSummaryRow = state.wrapper.children[summaryRowIndex]

        if (oldSummaryRow) {
          // todo: 更新汇总
          const newSummaryRow = createRow({ name: '合计' }, 'summary')
          state.wrapper.replaceChild(newSummaryRow, oldSummaryRow)
        }
      }

      function updatePageIndicator(startPage, endPage) {
        // 初始: 总行数 (所有分页数据之和); 最大可预览页面, 约定了 20
        const totalPages = Math.ceil(state.totalRows / config.pageSize)
        const maxAllowed = config.maxRenderedPages

        if (endPage >= maxAllowed - 1) {
          state.pageIndicator.innerHTML = `
          已加载全部可浏览数据（前 ${maxAllowed} 页）<br>
          全量共 ${totalPages.toLocaleString()} 页 ·
          <strong>建议导出 Excel</strong>
        `
        } else {
          state.pageIndicator.textContent = `显示第 ${startPage + 1}–${
            endPage + 1
          } 页 · 共 ${totalPages} 页 最多可预览 ${
            config.maxRenderedPages
          } 页哦!`
        }
      }

      // 首次加载数据 (表头, 汇总, 第一页)
      async function loadInitialData() {
        // 渲染静态行, 不依赖数据
        if (config.hasHeader) {
          // 从配置中获取 title 进行渲染
          state.wrapper.appendChild(createRow(null, 'header'))
        }

        if (config.showSummary) {
          // 空行占个位, 等下在更新数据即可
          state.wrapper.appendChild(createRow({ name: '合计' }, 'summary'))
        }

        // 加载第一页
        const page0 = await config.fetchPage(0)
        state.totalRows = page0.total
        // 缓存起来并整体渲染一把
        state.pageCache.set(0, page0.data)
        renderVisiblePages()

        // 加载汇总数据
        if (config.showSummary) {
          const summary = await config.fetchSummary()
          state.summaryRowData = summary
          updateSummaryDisplay()
        }

        updatePageIndicator(0, 0)
      }

      // 最最关键一步: 绑定事件 (
      function bindEvents() {
        // 事件01: 滚动分页
        state.scrollContainer.addEventListener('scroll', onScroll, {
          passive: true,
        })

        // 事件02: ...
      }

      function onScroll() {
        // scrollTop: 元素被垂直滚动的距离 px; 是 Element 接口内置属性;
        // clientHeight: 可视区高度, 不包含滚动虐, 边框, 外边距
        // 视口底部在内容中的位置: scrollTop + clientHeight (包含下面溢出的, 只是看不见但存在)

        // 01: 获取滚动容器, 当前滚动位置 和 可见高度
        const { scrollTop, clientHeight } = state.scrollContainer

        // 02: 计算数据区域, 在容器中的起始偏移 (跳过表头和总结行)
        let dataTop = 0
        if (config.hasHeader) dataTop += config.rowHeight.header
        if (config.showSummary) dataTop += config.rowHeight.summary

        // 03: 计算当前视口在数据区域中的上下边界(px)
        // ro  scollTop < dataTop, 则说明尚未滚出表头/总结行区域, 数据区为 0
        const visibleTop = scrollTop < dataTop ? 0 : scrollTop - dataTop
        const visibleBottom = scrollTop + clientHeight - dataTop

        // 04: 计算每一页在视觉上占据多少高度px (pageSize 行 * 每行行高)
        // 每页 100 条数据, 行高是 40px, 则每页的行高为 100 * 40 = 4000 px
        const pageHeight = config.pageSize * config.rowHeight.data

        // 05: 根据可视区域的像素位置, 反推出当前应该显示哪些页码
        // 滚动位置 -> 页: 将连续的内容流, 转为后续页面的拼接
        // (0, 0): 当前页; (0, 1); 预加载下一页;
        let startPage = Math.floor(visibleTop / pageHeight)
        let endPage = Math.floor(visibleBottom / pageHeight)

        // 06: 限制页码范围, 不要超过最大允许渲染的页数, 这里默认配置的 20页
        // 只限制上限, 因为页码不会小于0, 有表头和行高是必须配置的
        const maxPage = config.maxRenderedPages - 1
        if (startPage > maxPage) startPage = maxPage
        if (endPage > maxPage) endPage = maxPage

        // 07: 预加载: 在可见页前后, 各加载 bufferPages 页 (提升滚动流畅度)
        const buffer = config.bufferPages
        for (
          let p = Math.max(0, startPage - buffer); // 可见起始页 - 缓冲页
          p <= Math.min(endPage + buffer, maxPage); // 可见结束页 + 缓冲页
          p++
        ) {
          // 若这一页还没加载过, 则去加载并缓存
          if (!state.pageCache.has(p)) {
            loadAndCachePage(p)
          }
        }

        // 08: 重新渲染所有已缓存的页 (注意不是当前页的前后哦)
        renderVisiblePages()

        // 09: 更新指示器 UI
        updatePageIndicator(startPage, endPage)
      }

      // 主入口
      init()
    </script>
  </body>
</html>
